---
title: "Coordinating subject noun phrases"
bibliography: ../../semantics.bib
format:
  html:
    css: ../styles.css
    html-math-method: mathjax
    mathjax-config:
      loader: {load: ['[tex]/bussproofs','[tex]/bbox','[tex]/colorbox']}
      tex:
        packages: {'[+]': ['bussproofs','bbox','colorbox']}

---

::: {.hidden}
$$
\newcommand{\expr}[3]{\begin{array}{c}
#1 \\
\bbox[lightblue,5px]{#2}
\end{array} ⊢ #3}
\newcommand{\ct}[1]{\bbox[font-size: 0.8em]{\mathsf{#1}}}
\newcommand{\abbr}[1]{\bbox[transform: scale(0.95)]{\mathtt{#1}}}
\def\true{\ct{T}}
\def\false{\ct{F}}
$$
:::

To coordinate subject noun phrases like *Po* and *Tigress* in a sentence such as (@ex-po-tigress-slept), we had to make a novel move.

(@ex-po-tigress-slept) Po and Tigress slept.

Instead of the usual category $np$, we assigned these noun phrases the category $(s/(np\backslash s))$.
This means that they take a verb phrase to their right---something whose syntactic category is $(np\backslash s)$---and together with that verb phrase, they make a sentence (an $s$).

This is a strange reversal of roles:
typically, it is the verb phrase that takes the subject as *its* argument.
The verb phrase's syntactic category even says that that's what it does---it takes an $np$ to its left, and with that $np$, it makes a sentence.
But alas, now there is no longer an $np$ to the left of the verb phrase.
What's there instead is a souped up noun phrase---a taker of verb phrases, if you will.
Someone saying, "Hey verb phrase, remember how you were going to take me as your syntactic argument on your left and make a sentence? Well, now it is I who takes you as *my* argument on my *right* (don't worry, I'll still use you to make a sentence)! (Evil laugh.)"

Importantly, this is perfectly within the bounds of what we are allowed to do using our category system.
If some expression has category $X$, then we can also define an expression that takes an $X$ to its right to make a sentence by assigning it the category $(s/X)$.
We can still do this even if $X$ happens to be the category of a verb phrase, i.e., $(np\backslash s)$.

The whole reason we want to do this, of course, is in order to allow noun phrases to have a type that "ends in $t$".
Such types---which also include $(e → t)$ and $(e → (e → t))$---allow noun phrases to be coordinated using the scheme in [A general rule](general_rule.html).

In particular, if noun phrases have the syntactic category $(s/(np\backslash s))$, then they have the semantic type $((e → t) → t)$.
They denote functions from characteristic functions of sets of entities to truth values.
Put differently, they are characteristic functions of sets of characteristic functions (of sets of entities).
(See [this discussion](../applicative_cg/sem_types.html#third-example) again for some review.)

If we forced noun phrases to have the syntactic category $np$, we would also be limiting them to having the semantic type $e$ of entities---things that are neither truth values, nor functions into truth values, nor functions into functions into truth values, etc.
The scheme we developed to define the possible meanings of *and* and *or* would be unusable.

### Lexical entries for subject noun phrases

We can assign *Po* and *Tigress* the lexical entries in (@ex-lex-noun-phrases)

(@ex-lex-noun-phrases) a. $⟨\textit{Po}, (λf.f(\ct{p}))⟩ ⊢ (s/(np\backslash s))$
	b. $⟨\textit{Tigress}, (λf.f(\ct{ti}))⟩ ⊢ (s/(np\backslash s))$

Each of the meanings in these lexical entries takes a verb phrase meaning---a characteristic function---and obtains a truth value by applying that function to the entity the noun phrase usually denotes (i.e., $\ct{p}$ or $\ct{ti}$).
The idea is that the resulting sentence will denote $\true$ just in case the verb phrase characterizes a set that has that entity as one of its members.

Here's a derivation of *Po slept* to illustrate:

$$\begin{prooftree}
\AxiomC{\(⟨\textit{Po}, (λf.f(\ct{p}))⟩ ⊢ (s/(np\backslash s))\)}
\AxiomC{\(⟨\textit{slept}, (λx.\ct{sleep}(x))⟩ ⊢ (np\backslash s)\)}
\RightLabel{\(/\)}\BinaryInfC{\(\textit{Po slept}, (λf.f(\ct{p}))(λx.\ct{sleep}(x))⟩ ⊢ s\)}
\end{prooftree}$$

The resulting meaning representation can then be evaluated:

$$(λf.f(\ct{p}))(λx.\ct{sleep}(x))$$
$$⇒ (λx.\ct{sleep}(x))(\ct{p})$$
$$⇒ \ct{sleep}(\ct{p})$$

### The coordinator

The meaning for *and* that we want in order to coordinate noun phrases like that in (@ex-po-tigress-slept) is given by the lexical entry in (@ex-lex-and-np).

(@ex-lex-and-np) $⟨\textit{and}_{(s/(np\backslash s))}, \ct{and}_{((e → t) → t)}⟩ ⊢ (((s/(np\backslash s))\backslash(s/(np\backslash s)))/(s/(np\backslash s)))$

What is $\ct{and}_{((e → t) → t)}$?
If we follow the scheme given in [A general rule](general_rule.html), we can see that it is defined as:

$$\ct{and}_{((e → t) → t)} = (λf.(λg.(λx.\ct{and}_{t}(f(x))(g(x)))))$$

$$= (λf.(λg.(λx.f(x) = g(x) = \true)))$$

Here, the $f$ and $g$ represent noun phrase meanings (functions from characteristic functions to truth values), and the $x$ represents a verb phrase meaning (a characteristic function).

### An example

Here is an example derivation for the sentence in (@ex-po-tigress-slept):

$$\begin{prooftree}
\AxiomC{\(⟨\textit{Po}, (λf.f(\ct{p}))⟩ ⊢ (s/(np\backslash s))\)}
\AxiomC{\(⟨\textit{and}_{(s/(np\backslash s))}, \ct{and}_{((e → t) → t)}⟩ ⊢ (((s/(np\backslash s))\backslash(s/(np\backslash s)))/(s/(np\backslash s)))\)}
\AxiomC{\(⟨\textit{Tigress}, (λf.f(\ct{ti}))⟩ ⊢ (s/(np\backslash s))\)}
\RightLabel{\(/\)}\BinaryInfC{\(⟨\textit{and Tigress}, \ct{and}_{((e → t) → t)}((λf.f(\ct{ti})))⟩ ⊢ ((s/(np\backslash s))\backslash(s/(np\backslash s)))\)}
\RightLabel{\(\backslash\)}\BinaryInfC{\(⟨\textit{Po and\(_{(s/(np\backslash s))}\) Tigress}, \ct{and}_{((e → t) → t)}((λf.f(\ct{ti})))((λf.f(\ct{p})))⟩ ⊢ (s/(np\backslash s))\)}
\AxiomC{\(⟨\textit{slept}, (λx.\ct{sleep}(x))⟩ ⊢ (np\backslash s)\)}
\RightLabel{\(/\)}\BinaryInfC{\(⟨\textit{Po and\(_{(s/(np\backslash s))}\) Tigress slept}, \ct{and}_{((e → t) → t)}((λf.f(\ct{ti})))((λf.f(\ct{p})))((λx.\ct{sleep}(x)))⟩ ⊢ s\)}
\end{prooftree}$$

Let's evaluate the result by first unfolding the definition of $\ct{and}_{((e → t) → t)}$

$$\ct{and}_{((e → t) → t)}((λf.f(\ct{ti})))((λf.f(\ct{p})))((λx.\ct{sleep}(x)))$$
$$= (λf.(λg.(λx.f(x) = g(x) = \true)))((λf.f(\ct{ti})))((λf.f(\ct{p})))((λx.\ct{sleep}(x)))$$

and then reducing the resulting expression, one step at a time:

$$(λf.(λg.(λx.f(x) = g(x) = \true)))((λf.f(\ct{ti})))((λf.f(\ct{p})))((λx.\ct{sleep}(x)))$$
$$⇒ (λg.(λx.(λf.f(\ct{ti}))(x) = g(x) = \true))((λf.f(\ct{p})))((λx.\ct{sleep}(x)))$$
$$⇒ (λx.(λf.f(\ct{ti}))(x) = (λf.f(\ct{p}))(x) = \true)((λx.\ct{sleep}(x)))$$
$$⇒ (λf.f(\ct{ti}))((λx.\ct{sleep}(x))) = (λf.f(\ct{p}))((λx.\ct{sleep}(x))) = \true$$
$$⇒ (λx.\ct{sleep}(x))(\ct{ti}) = (λf.f(\ct{p}))((λx.\ct{sleep}(x))) = \true$$
$$⇒ \ct{sleep}(\ct{ti}) = (λf.f(\ct{p}))((λx.\ct{sleep}(x))) = \true$$
$$⇒ \ct{sleep}(\ct{ti}) = (λx.\ct{sleep}(x))(\ct{p}) = \true$$
$$⇒ \ct{sleep}(\ct{ti}) = \ct{sleep}(\ct{p}) = \true$$

The truth value we get at the end is $\true$ just in case $\ct{sleep}$ is true of both $\ct{ti}$ and $\ct{p}$---that is, if both Tigress and Po slept.

(I would really recommend reading each of these lines carefully and ensuring that you see which particular reduction has taken place!)
